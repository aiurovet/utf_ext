import 'dart:typed_data';
import 'package:file/file.dart';
import 'package:file/memory.dart';
import 'package:utf_ext/utf_ext.dart';

/// UTF test data
///
class UtfAbc {
  /// Empty bytes
  ///
  static final bytes = <UtfType, Uint8List> {
    UtfType.none: Uint8List.fromList(<int>[
      0x41,
      0x62,
      0x63,
      0xD0,
      0x90,
      0xD0,
      0xB1,
      0xD0,
      0xB2,
      0xD0,
      0xB3,
      0xE1,
      0x83,
      0x85,
      0xD5,
      0xB6,
      0xE0,
      0xB9,
      0x92,
      0xE4,
      0xBF,
      0xB0,
      0xF0,
      0x90,
      0xA1,
      0x81,
      0xE2,
      0x84,
      0xB5,
      0xF0,
      0x9D,
      0x92,
      0x9C,
    ]),

    UtfType.utf8: Uint8List.fromList(<int>[
      0xEF,
      0xBB,
      0xBF,
      0x41,
      0x62,
      0x63,
      0xD0,
      0x90,
      0xD0,
      0xB1,
      0xD0,
      0xB2,
      0xD0,
      0xB3,
      0xE1,
      0x83,
      0x85,
      0xD5,
      0xB6,
      0xE0,
      0xB9,
      0x92,
      0xE4,
      0xBF,
      0xB0,
      0xF0,
      0x90,
      0xA1,
      0x81,
      0xE2,
      0x84,
      0xB5,
      0xF0,
      0x9D,
      0x92,
      0x9C,
    ]),

    UtfType.utf16be: Uint8List.fromList(<int>[
      0xFE,
      0xFF,
      0x00,
      0x41,
      0x00,
      0x62,
      0x00,
      0x63,
      0x04,
      0x10,
      0x04,
      0x31,
      0x04,
      0x32,
      0x04,
      0x33,
      0x10,
      0xC5,
      0x05,
      0x76,
      0x0E,
      0x52,
      0x4F,
      0xF0,
      0xD8,
      0x02,
      0xDC,
      0x41,
      0x21,
      0x35,
      0xD8,
      0x35,
      0xDC,
      0x9C,
    ]),

    /// Bytes for UTF-16LE
    ///
    UtfType.utf16le: Uint8List.fromList(<int>[
      0xFF,
      0xFE,
      0x41,
      0x00,
      0x62,
      0x00,
      0x63,
      0x00,
      0x10,
      0x04,
      0x31,
      0x04,
      0x32,
      0x04,
      0x33,
      0x04,
      0xC5,
      0x10,
      0x76,
      0x05,
      0x52,
      0x0E,
      0xF0,
      0x4F,
      0x02,
      0xD8,
      0x41,
      0xDC,
      0x35,
      0x21,
      0x35,
      0xD8,
      0x9C,
      0xDC,
    ]),

    /// Bytes for UTF-32BE
    ///
    UtfType.utf32be: Uint8List.fromList(<int>[
      0x00,
      0x00,
      0xFE,
      0xFF,
      0x00,
      0x00,
      0x00,
      0x41,
      0x00,
      0x00,
      0x00,
      0x62,
      0x00,
      0x00,
      0x00,
      0x63,
      0x00,
      0x00,
      0x04,
      0x10,
      0x00,
      0x00,
      0x04,
      0x31,
      0x00,
      0x00,
      0x04,
      0x32,
      0x00,
      0x00,
      0x04,
      0x33,
      0x00,
      0x00,
      0x10,
      0xC5,
      0x00,
      0x00,
      0x05,
      0x76,
      0x00,
      0x00,
      0x0E,
      0x52,
      0x00,
      0x00,
      0x4F,
      0xF0,
      0x00,
      0x01,
      0x08,
      0x41,
      0x00,
      0x00,
      0x21,
      0x35,
      0x00,
      0x01,
      0xD4,
      0x9C,
    ]),

    /// Bytes for UTF-32LE
    ///
    UtfType.utf32le: Uint8List.fromList(<int>[
      0xFF,
      0xFE,
      0x00,
      0x00,
      0x41,
      0x00,
      0x00,
      0x00,
      0x62,
      0x00,
      0x00,
      0x00,
      0x63,
      0x00,
      0x00,
      0x00,
      0x10,
      0x04,
      0x00,
      0x00,
      0x31,
      0x04,
      0x00,
      0x00,
      0x32,
      0x04,
      0x00,
      0x00,
      0x33,
      0x04,
      0x00,
      0x00,
      0xC5,
      0x10,
      0x00,
      0x00,
      0x76,
      0x05,
      0x00,
      0x00,
      0x52,
      0x0E,
      0x00,
      0x00,
      0xF0,
      0x4F,
      0x00,
      0x00,
      0x41,
      0x08,
      0x01,
      0x00,
      0x35,
      0x21,
      0x00,
      0x00,
      0x9C,
      0xD4,
      0x01,
      0x00,
    ]),
  };

  /// Source string
  ///
  static const complexStr = "AbcАбвгჅն๒俰𐡁ℵ𝒜";

  /// Dumps bytes as hex numbers
  ///
  static void dumpAsHex(UtfType type) {
    final complexBytes =
        UtfEncoderSink(null, type: type, withBom: true).convert(complexStr);
    print(complexBytes
        .map((x) =>
            '0x${(x < 0x10 ? '0' : '')}${x.toRadixString(0x10).toUpperCase()}, ')
        .join(''));
  }

  /// Loop through all UTF types and run a test (non-blocking)
  ///
  static Future<void> forEachType(File file, Future<void> Function(UtfType, File) testProc) async {
    for (var type in UtfType.values) {
      await testProc(type, file);
    }
  }

  /// Loop through all UTF types and run a test (blocking)
  ///
  static void forEachTypeSync(File file, void Function(UtfType, File) testProc) {
    for (var type in UtfType.values) {
      testProc(type, file);
    }
  }

  static Uint8List getBytes(UtfType type) => bytes[type]!;

  static File getDummyFile() => MemoryFileSystem().file('x');

  /// Test data setup
  ///
  static Future<void> init(File file) async {
    await file.create(recursive: true);
    await file.writeUtfAsString(complexStr);
  }
}
